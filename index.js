/**
 * createRanking
 * 
 * @description create an object where the key are the values of the array and the values are the order like : {"1": 1, "7": 2,"9": 3,"10": 4}
 * @param {array} List array of INT or FLOAT or STRING ( will be casted to FLOAT ) they can be positive or negative eg: ["10","7","1","9"]
 * @returns {object} returns object eg : {"1": 1, "7": 2,"9": 3,"10": 4}
 * @example :
 * createRanking([1, 9, 10, 9, 7, 1, 1]) === {"1": 4,"7": 3,"9": 2,"10": 1}); // true
 */
exports.createRanking = (list) => {

    if (!Array.isArray(list)) {
        throw new Error(`The parameter should be an array we got ${typeof list}`);
    }

    // remove duplicate values from the array
    let listUniq = new Set();

    for (let element of list) {

        // let's be sure we cast string to floats 
        element = (typeof element === "string") ? parseFloat(element) : element;

        listUniq.add(element);
    }

    listUniq = [...listUniq];

    // order the values by DESC 
    listUniq = listUniq.sort((a, b) => b - a);

    // create an object where the key are the values of the aray 
    // and the values are the order 
    // like 
    // const rank = {
    //     "1": 1,
    //     "7": 2,
    //     "9": 3,
    //     "10": 4
    // }

    const rank = {};

    for (let i = 0; i < listUniq.length; i++) {

        rank[listUniq[i]] = i + 1;
    }

    return rank;

};



/**
 * getRank
 * 
 * @description returns rank from a score Object generated by createRanking
 * @param {object} rank object containing the ranking generated by createRanking() 
 * @returns {integer} the rank as an interger
 * @example :
 * getRank(-0.34,createRanking([-1, -0.34, -1.2, 3, 9, 8, -3])) === 4 // true
 */
exports.getRank = (score, rank) => rank[parseFloat(score)];